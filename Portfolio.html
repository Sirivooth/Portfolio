<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive 3D Portfolio</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
  .overlay {
    position:absolute; top:20%; left:20%; width:60%; height:60%;
    background:#fff; color:#000; display:none; opacity:0;
    padding:20px; font-family:sans-serif; border-radius:10px;
    box-shadow:0 0 15px rgba(0,0,0,0.6);
  }
  .overlay button { margin-top:10px; padding:5px 10px; cursor:pointer; }
</style>
</head>
<body>

<!-- Overlay Panels -->
<div id="overlay-about" class="overlay">
  <h1>About Me</h1>
  <p>My name is Sirivooth Theinkrua
  <br>I am a student at Kasetsart University Kamphaeng Saen, Nakhon Pathom.
  <br>Faculty of Liberal Arts and Science, majoring in Computer Science.
  </p>
  <button onclick="closeOverlay('overlay-about')">Close</button>
</div>

<div id="overlay-contact" class="overlay">
  <h1>Contact</h1>
  <p>Gmail: Sirivooth@gmail.com<br>Phone: 097-012-1368</p>
  <button onclick="closeOverlay('overlay-contact')">Close</button>
</div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

<script>
// Scene
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0xaaaaaa,0.005);
let fogTime=0;

// Camera
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
const cameraDefaultPos = new THREE.Vector3(80, 60, 120);
camera.position.set(0, 20, 60);

// Renderer
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio*0.6);
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMappingExposure = 1.4;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera,renderer.domElement);
controls.enableDamping = true;

// Lights
scene.add(new THREE.AmbientLight(0xffffff,0.25));
const hemiLight = new THREE.HemisphereLight(0xaaaaff,0x444422,0.6);
hemiLight.position.set(0,50,0);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff,1.2);
dirLight.position.set(-50,50,30);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.radius = 1;
dirLight.shadow.camera.left=-100;
dirLight.shadow.camera.right=100;
dirLight.shadow.camera.top=100;
dirLight.shadow.camera.bottom=-100;
dirLight.shadow.bias=-0.0001;
scene.add(dirLight);

const spotLight = new THREE.SpotLight(0xffd27f,2,200,Math.PI/6,0.4,1);
spotLight.position.set(0,50,50);
spotLight.target.position.set(0,0,0);
spotLight.castShadow = true;
scene.add(spotLight); scene.add(spotLight.target);

const pointLightWarm = new THREE.PointLight(0xffaa66,0.5,100);
pointLightWarm.position.set(-20,15,20);
scene.add(pointLightWarm);

const pointLightCool = new THREE.PointLight(0x66aaff,0.5,100);
pointLightCool.position.set(20,15,-20);
scene.add(pointLightCool);

// Environment
const exrLoader = new THREE.EXRLoader();
const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

exrLoader.load("docklands_02_1k.exr", 
  texture=>{
    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
    scene.background = envMap; 
    scene.environment = envMap; 
    texture.dispose();
  },
  undefined,
  ()=>{ scene.background=new THREE.Color(0x666666); }
);

// Ground
const texLoader = new THREE.TextureLoader();
const floorDiffuse = texLoader.load("concrete_pavers_02_diff_1k.jpg");
const floorNormal = texLoader.load("concrete_pavers_02_nor_gl_1k.jpg");
const floorRough = texLoader.load("concrete_pavers_02_rough_1k.jpg");
const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
[floorDiffuse, floorNormal, floorRough].forEach(t=>{
    t.wrapS = t.wrapT = THREE.RepeatWrapping;
    t.repeat.set(10,10);
    t.anisotropy = maxAnisotropy;
});
const groundMat = new THREE.MeshStandardMaterial({
    map: floorDiffuse,
    normalMap: floorNormal,
    roughnessMap: floorRough,
    metalness: 0,
    roughness: 1
});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(300,300), groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// City Model
const cityLoader = new THREE.GLTFLoader();
cityLoader.load("desert_town.glb", function(gltf) {
    const city = gltf.scene;
    city.traverse(n => { if(n.isMesh){ n.castShadow=true; n.receiveShadow=true; } });
    city.position.set(0,1.5,-60);
    city.scale.set(18,18,18);
    scene.add(city);
}, undefined, function(error){ console.error(error); });


// ---------- Load Cakes ----------
let cakeModels = []; // เก็บโมเดลเค้กทั้งหมด

// Loader1
const loader1 = new THREE.GLTFLoader();
loader1.load(
  'handpainted_watercolor_cake.glb.circ',
  function (gltf) {
    const model = gltf.scene;

    function createToonPBRMaterial(baseColor = 0xffffff) {
      const mat = new THREE.MeshPhysicalMaterial({
        color: baseColor,
        metalness: 0.1,
        roughness: 0.5,
        clearcoat: 1.0,
        clearcoatRoughness: 0.25,
        reflectivity: 0.3,
      });
      const gradientTex = new THREE.TextureLoader().load(
        'https://threejs.org/examples/textures/gradientMaps/threeTone.jpg'
      );
      gradientTex.minFilter = THREE.NearestFilter;
      gradientTex.magFilter = THREE.NearestFilter;
      mat.gradientMap = gradientTex;
      return mat;
    }

    model.traverse(n => {
      if (n.isMesh) {
        n.castShadow = true;
        n.receiveShadow = true;
        n.material = createToonPBRMaterial(0xffccaa);
      }
    });

    model.scale.set(2.5, 2.5, 2.5);
    model.position.set(140, 0, -80);
    scene.add(model);
    cakeModels.push(model);

    const outline = model.clone();
    outline.traverse(n => {
      if (n.isMesh) {
        n.material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
        n.scale.multiplyScalar(1.03);
      }
    });
    scene.add(outline);
  },
  undefined,
  function (error) { console.error(error); }
);

// Loader2
const loader2 = new THREE.GLTFLoader();
loader2.load(
  'cake_with_cherry.glb.circ',
  function (gltf) {
    const model = gltf.scene;
    model.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
    model.scale.set(25, 25, 25);
    model.position.set(120, 0, -70);
    scene.add(model);
    cakeModels.push(model);
  },
  undefined,
  function (error) { console.error(error); }
);

// Loader3
const loader3 = new THREE.GLTFLoader();
loader3.load(
  'roll_cake.glb.circ',
  function (gltf) {
    const model = gltf.scene;
    model.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
    model.scale.set(25,25, 25);
    model.position.set(90, 0, -80);
    scene.add(model);
    cakeModels.push(model);
  },
  undefined,
  function (error) { console.error(error); }
);

// Robot
let mixer;
const loaderGLTF = new THREE.GLTFLoader();
loaderGLTF.load("https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb", function(gltf){
    const model = gltf.scene;
    model.traverse(n=>{if(n.isMesh){n.castShadow=true;n.receiveShadow=true;}});
    model.position.set(0,0,10);
    model.scale.set(1.2,1.2,1.2);
    scene.add(model);
    mixer = new THREE.AnimationMixer(model);
    const clip = THREE.AnimationClip.findByName(gltf.animations,"Dance") || THREE.AnimationClip.findByName(gltf.animations,"Idle");
    if(clip) mixer.clipAction(clip).play();
});

// Name
let nameModel;
const nameLoader = new THREE.GLTFLoader();
nameLoader.load("Name.glb", function(gltf){
  nameModel = gltf.scene;
  nameModel.traverse(n=>{
      if(n.isMesh){
          n.castShadow=true;
          n.receiveShadow=true;
          n.material = new THREE.MeshStandardMaterial({color:0xffc107,metalness:0.8,roughness:0.3,emissive:0x332200});
      }
  });
  nameModel.position.set(60,1.5,40);
  nameModel.scale.set(6,3,3);
  scene.add(nameModel);
});

// Photo with Gold Frame
let photoMesh, frameMesh;
texLoader.load("Photo.jpg", function(texture){
    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    const photoWidth = 20, photoHeight = 20;
    photoMesh = new THREE.Mesh(new THREE.PlaneGeometry(photoWidth, photoHeight),
        new THREE.MeshPhysicalMaterial({ map:texture, transparent:true, metalness:0.3, roughness:0.2, clearcoat:1, clearcoatRoughness:0.05 })
    );
    photoMesh.position.set(-20,10,20);
    photoMesh.castShadow = true; photoMesh.receiveShadow = true;

    const frameThickness = 0.6, frameDepth=1.2;
    frameMesh = new THREE.Mesh(new THREE.BoxGeometry(photoWidth+frameThickness, photoHeight+frameThickness, frameDepth),
        new THREE.MeshPhysicalMaterial({ color:0xffd700, metalness:1, roughness:0.2, clearcoat:1, clearcoatRoughness:0.05 })
    );
    frameMesh.position.set(photoMesh.position.x, photoMesh.position.y, photoMesh.position.z-0.7);
    frameMesh.castShadow=true; frameMesh.receiveShadow=true;

    scene.add(photoMesh); scene.add(frameMesh);

    const photoLight = new THREE.SpotLight(0xffffff, 2, 80, Math.PI/6, 0.5);
    photoLight.position.set(-20,25,30);
    photoLight.target = photoMesh;
    scene.add(photoLight); scene.add(photoLight.target);

    const warmLight = new THREE.PointLight(0xffcc88,0.5,50);
    warmLight.position.set(-15,15,25); scene.add(warmLight);
});

// Clickable Text
let clickableObjects=[];
let startTextPos = new THREE.Vector3(70,7,300); // ตำแหน่ง Start
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font){
    const texts=[
        {name:"About Me",pos:[90,15,200],overlay:"overlay-about"},
        {name:"Project",pos:[50,15,200],overlay:null},
        {name:"Contact",pos:[70,15,200],overlay:"overlay-contact"},
        {name:"Start",pos:[70,7,300],overlay:null} // ไม่เปิด overlay
    ];
    texts.forEach(t=>{
        const geo = new THREE.TextGeometry(t.name,{font:font,size:2,height:0.3,bevelEnabled:true,bevelThickness:0.05,bevelSize:0.05});
        const mat = new THREE.MeshStandardMaterial({color:0xff00ff,metalness:0.5,roughness:0.2});
        const mesh = new THREE.Mesh(geo,mat);
        mesh.position.set(...t.pos);
        mesh.userData.overlay = t.overlay;
        mesh.name = t.name;
        scene.add(mesh);
        clickableObjects.push(mesh);
    });

    gsap.to(camera.position,{x:startTextPos.x+10, y:startTextPos.y+10, z:startTextPos.z+30, duration:3, ease:"power2.inOut", onUpdate:()=>{
        camera.lookAt(startTextPos);
        controls.update();
    }});
});

// Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredObject=null;
function onMouseMove(event){
    mouse.x = (event.clientX/window.innerWidth)*2-1;
    mouse.y = -(event.clientY/window.innerHeight)*2+1;
    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(clickableObjects);
    if(intersects.length>0){
        if(hoveredObject!=intersects[0].object){
            if(hoveredObject) hoveredObject.material.color.set(0xff00ff);
            hoveredObject=intersects[0].object;
            hoveredObject.material.color.set(0xffff00);
        }
        document.body.style.cursor="pointer";
    } else {
        if(hoveredObject) hoveredObject.material.color.set(0xff00ff);
        hoveredObject=null;
        document.body.style.cursor="default";
    }
}
window.addEventListener('mousemove',onMouseMove);

// Overlay functions
function openOverlay(id){
  const overlay = document.getElementById(id);
  overlay.style.display='block';
  gsap.fromTo(overlay,{opacity:0,y:-30},{opacity:1,y:0,duration:0.6,ease:"power2.out"});
}
function closeOverlay(id){
  const overlay = document.getElementById(id);
  gsap.to(overlay,{opacity:0,y:-30,duration:0.6,ease:"power2.in",onComplete:()=>{overlay.style.display='none';}});
  gsap.to(camera.position,{x:cameraDefaultPos.x,y:cameraDefaultPos.y,z:cameraDefaultPos.z,duration:2,onUpdate:()=>{camera.lookAt(0,5,0); controls.update();}});
}

// Focus on Cakes Function
function focusOnCakes(){
    if(cakeModels.length === 0) return;
    let center = new THREE.Vector3(0,0,0);
    cakeModels.forEach(c => center.add(c.position));
    center.divideScalar(cakeModels.length);
    const cameraTargetPos = center.clone().add(new THREE.Vector3(0, 20, 50));
    gsap.to(camera.position, {
        x: cameraTargetPos.x,
        y: cameraTargetPos.y,
        z: cameraTargetPos.z,
        duration: 3,
        ease: "power2.inOut",
        onUpdate: () => {
            camera.lookAt(center);
            controls.update();
        }
    });
}

// Mouse Click
function onMouseClick(){
    if(hoveredObject){
        gsap.to(hoveredObject.position, {
            y: hoveredObject.position.y - 0.3,
            duration: 0.1,
            yoyo: true,
            repeat: 1
        });

        if(hoveredObject.name === "Project"){
            focusOnCakes();
            return;
        }

        if (hoveredObject.name === "Start") {
            cameraTour();
            return;
        }

        let targetPos, lookAtTarget;
        if (hoveredObject.userData.overlay && photoMesh) {
            targetPos = photoMesh.position.clone().add(new THREE.Vector3(5,3,10));
            lookAtTarget = photoMesh.position.clone();
            openOverlay(hoveredObject.userData.overlay);
        } else { 
            targetPos = cameraDefaultPos.clone(); 
            lookAtTarget = new THREE.Vector3(0,5,0);
        }

        gsap.to(camera.position, {
            x: targetPos.x,
            y: targetPos.y,
            z: targetPos.z,
            duration: 2,
            ease: "power2.inOut",
            onUpdate: () => {
                camera.lookAt(lookAtTarget);
                controls.update();
            }
        });
    }
}
window.addEventListener('click', onMouseClick);

// Animate
const clock=new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    if(mixer) mixer.update(delta);
    fogTime += delta*0.5;
    scene.fog.density = 0.005 + Math.sin(fogTime)*0.001;

    if(nameModel){
        const t = clock.getElapsedTime();
        nameModel.position.y = 5 + Math.sin(t*2)*0.25;
        nameModel.position.x = 60 + Math.sin(t*1)*0.5;
    }
    if(photoMesh){
        const t = clock.getElapsedTime();
        photoMesh.position.y = 10 + Math.sin(t*1.5)*0.5;
        photoMesh.position.x = -20 + Math.sin(t*0.7)*0.7;
        if(frameMesh){ frameMesh.position.x = photoMesh.position.x; frameMesh.position.y = photoMesh.position.y; }
    }
    clickableObjects.forEach(obj=>{ obj.position.y += Math.sin(clock.getElapsedTime())*0.001; });
    controls.update();
    renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});

// Camera Tour
function cameraTour() {
  const tourPoints = [
    { pos: new THREE.Vector3(70, 20, 250), look: new THREE.Vector3(70, 10, 200) },
    { pos: new THREE.Vector3(90, 20, 220), look: new THREE.Vector3(90, 10, 200) },
    { pos: new THREE.Vector3(110, 20, 210), look: new THREE.Vector3(110, 10, 200) },
    { pos: new THREE.Vector3(0, 40, 100), look: new THREE.Vector3(0, 10, 0) }
  ];
  let delay = 0;
  tourPoints.forEach((p, i) => {
    gsap.to(camera.position, {
      x: p.pos.x,
      y: p.pos.y,
      z: p.pos.z,
      duration: 4,
      delay: delay,
      ease: "power2.inOut",
      onUpdate: () => { camera.lookAt(p.look); controls.update(); }
    });
    delay += 5;
  });
  gsap.to(camera.position, {
    x: cameraDefaultPos.x,
    y: cameraDefaultPos.y,
    z: cameraDefaultPos.z,
    duration: 3,
    delay: delay + 1,
    ease: "power2.inOut",
    onUpdate: () => { camera.lookAt(0, 5, 0); controls.update(); }
  });
}
</script>
</body>
</html>

